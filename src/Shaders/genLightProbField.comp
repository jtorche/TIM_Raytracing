#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

//#define NO_LPF
// #define IGNORE_BACKFACE
#define NUM_THREADS_PER_GROUP UPDATE_LPF_NUM_PROBS_PER_GROUP

#include "core/system.glsl"
#include "bvh/bvhBindings_cpp.glsl"
#include "struct_cpp.glsl"
#include "lightprob/lightprob.glsl"

layout(push_constant) uniform pushConstantBlock
{
	PushConstants g_Constants;
};

layout(std430, set=0, binding = g_CstBuffer_bind)
uniform CstBuffer_block
{
	GenLightProbFieldConstants g_lpfCst;
};

layout(std430, binding = g_tracingResult_bind) buffer TracingResult
{
	uvec4 g_tracingData[];
};

layout(std430, binding = g_outputBuffer_bind) writeonly buffer OutputLayout
{
    float g_irradiance[];
};

layout(set = 0, binding = g_lpfTextures_bind, rgba16f) uniform readonly image3D g_lpfTextures[7];
#include "lightprob/fetchSH_inline.glsl"

#include "baseRaytracingPass.glsl"
#include "lightprob/lightprobHelpers.glsl"

layout (local_size_x = UPDATE_LPF_NUM_PROBS_PER_GROUP) in;
void main()
{
	uint probBatchId = gl_WorkGroupID.x;
	uint rayId = gl_WorkGroupID.y;
    uint probIndex = gl_LocalInvocationID.x + UPDATE_LPF_NUM_PROBS_PER_GROUP * probBatchId;
	uint sampleIndex = probIndex * NUM_RAYS_PER_PROB + rayId;

	SunDirColor sun;
	sun.sunDir = g_lpfCst.sunDir.xyz;
	sun.sunColor = g_lpfCst.sunColor.xyz;

	LightProbFieldHeader lpfHeader;
	lpfHeader.aabb.minExtent = g_lpfCst.lpfMin.xyz;
	lpfHeader.aabb.maxExtent = g_lpfCst.lpfMax.xyz;
	lpfHeader.resolution = g_lpfCst.lpfResolution.xyz;
	lpfHeader.step = computeLpfStep(lpfHeader.resolution, lpfHeader.aabb);

	uvec3 probCoord = getLightProbCoord(probIndex, lpfHeader.resolution);
	vec3 probPosition = getLightProbPosition(probCoord, lpfHeader.resolution, lpfHeader.aabb);

	Ray ray = createRay(probPosition, g_lpfCst.rays[rayId].xyz);

#ifdef TRACING_STEP
	ClosestHit closestHit;
	rayTrace(ray, closestHit);

	g_tracingData[sampleIndex * 2] = ClosestHit_getHitData(closestHit);
	g_tracingData[sampleIndex * 2 + 1].xy = computeAdditionalHitData(ray, closestHit, sun, lpfHeader);
#else
	Triangle tri = unpackTriangle(g_tracingData[sampleIndex * 2].xyz);
	float t = uintBitsToFloat(g_tracingData[sampleIndex * 2].w);
	uint shadowMask = g_tracingData[sampleIndex * 2 + 1].x;

	vec3 lit = computeLighting(sun, lpfHeader, shadowMask, ray, t, tri);

	g_irradiance[sampleIndex*3 + 0] = lit.x;
	g_irradiance[sampleIndex*3 + 1] = lit.y;
	g_irradiance[sampleIndex*3 + 2] = lit.z;
#endif
}