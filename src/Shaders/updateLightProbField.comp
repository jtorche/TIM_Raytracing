#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "core/system.glsl"
#include "lightprob/lightprob.glsl"
#include "struct_cpp.glsl"

const float M_PI = 3.14159265358979323846264338327950288;

layout(std140, set=0, binding = 0)
uniform CstBuffer_block
{
	GenLightProbFieldConstants g_lpfCst;
};

layout(std430, set=0, binding = 1) readonly buffer InputLayout0
{
    float g_shCoef[];
};

layout(std430, set=0, binding = 2) readonly buffer InputLayout1
{
    float g_irradiance[];
};

// SH field output
layout(set = 0, binding = 3, rgba16f) uniform image3D g_lpfTextures[7];
#include "lightprob/storeSH_inline.glsl"
#include "lightprob/fetchSH_inline.glsl"
#include "lightprob/lightprobHelpers.glsl"

layout (local_size_x = UPDATE_LPF_LOCALSIZE) in;
void main()
{
	uint probBatchId = gl_WorkGroupID.x;
	uint probIndex = probBatchId * UPDATE_LPF_LOCALSIZE + gl_LocalInvocationID.x;

	const uint numProb = g_lpfCst.lpfResolution.x * g_lpfCst.lpfResolution.y * g_lpfCst.lpfResolution.z;
	if(probIndex < numProb)
	{
		SH9Color shCoef = getZeroInitializedSHCoef();
		for(uint i=0 ; i<NUM_RAYS_PER_PROB ; ++i)
		{
			uint sampleIndex = (probIndex * NUM_RAYS_PER_PROB + i) * 3;
			vec3 L = vec3(g_irradiance[sampleIndex], g_irradiance[sampleIndex+1], g_irradiance[sampleIndex+2]);
			for (uint j = 0; j < 9; ++j)
			{
				float w = g_shCoef[i * 9 + j];
				shCoef.w[j] += L * w;
			}
		}

		// Normalize coefficients
		for (uint j = 0; j < 9; ++j)
			shCoef.w[j] *= (4.0*M_PI / NUM_RAYS_PER_PROB);

		ivec3 probCoord = getLightProbCoord(probIndex, g_lpfCst.lpfResolution.xyz);
		SH9Color prevSh = fetchSH9(probCoord);
		
		storeSH9(probCoord, lerp(prevSh, shCoef, 0.05));
		//storeSH9(probCoord, getZeroInitializedSHCoef());
	}
}