#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "system.glsl"
#include "struct_cpp.glsl"
#include "lightprob.glsl"
#include "lightprobHelpers.glsl"

const float M_PI = 3.14159265358979323846264338327950288;

layout(std140, set=0, binding = 0)
uniform CstBuffer_block
{
	GenLightProbFieldConstants g_lpfCst;
};

layout(std430, set=0, binding = 1) readonly buffer InputLayout0
{
    float g_shCoef[];
};

layout(std430, set=0, binding = 2) readonly buffer InputLayout1
{
    float g_irradiance[];
};

// SH field output
layout(set = 0, binding = 3, rgba16f) uniform writeonly image3D g_lightProbFieldR[2];
layout(set = 0, binding = 4, rgba16f) uniform writeonly image3D g_lightProbFieldG[2];
layout(set = 0, binding = 5, rgba16f) uniform writeonly image3D g_lightProbFieldB[2];
layout(set = 0, binding = 6, rgba16f) uniform writeonly image3D g_lightProbFieldY00;

layout (local_size_x = UPDATE_LPF_LOCALSIZE) in;
void main()
{
	uint probBatchId = gl_WorkGroupID.x;
	uint probIndex = probBatchId * UPDATE_LPF_LOCALSIZE + gl_LocalInvocationID.x;

	vec3 mean = vec3(0,0,0);

	const uint numProb = g_lpfCst.lpfResolution.x * g_lpfCst.lpfResolution.y * g_lpfCst.lpfResolution.z;
	if(probIndex < numProb)
	{
		SH9Color shCoef = getZeroInitializedSHCoef();
		for(uint i=0 ; i<NUM_RAYS_PER_PROB ; ++i)
		{
			uint sampleIndex = (probIndex * NUM_RAYS_PER_PROB + i) * 3;
			vec3 L = vec3(g_irradiance[sampleIndex], g_irradiance[sampleIndex+1], g_irradiance[sampleIndex+2]);
			mean += L;
			for (uint j = 0; j < 9; ++j)
			{
				float w = g_shCoef[i * 9 + j];
				shCoef.w[j] += L * w;
			}
		}

		// Normalize coefficients
		for (uint j = 0; j < 9; ++j)
			shCoef.w[j] *= (4.0*M_PI / NUM_RAYS_PER_PROB);

		mean /= NUM_RAYS_PER_PROB;
		ivec3 probCoord = getLightProbCoord(probIndex, g_lpfCst.lpfResolution.xyz);

		imageStore(g_lightProbFieldY00, probCoord, vec4(shCoef.w[0], 0));

		imageStore(g_lightProbFieldR[0], probCoord, vec4(shCoef.w[1].r, shCoef.w[2].r, shCoef.w[3].r, shCoef.w[4].r));
		imageStore(g_lightProbFieldR[1], probCoord, vec4(shCoef.w[5].r, shCoef.w[6].r, shCoef.w[7].r, shCoef.w[8].r));
		
		imageStore(g_lightProbFieldG[0], probCoord, vec4(shCoef.w[1].g, shCoef.w[2].g, shCoef.w[3].g, shCoef.w[4].g));
		imageStore(g_lightProbFieldG[1], probCoord, vec4(shCoef.w[5].g, shCoef.w[6].g, shCoef.w[7].g, shCoef.w[8].g));
		
		imageStore(g_lightProbFieldB[0], probCoord, vec4(shCoef.w[1].b, shCoef.w[2].b, shCoef.w[3].b, shCoef.w[4].b));
		imageStore(g_lightProbFieldB[1], probCoord, vec4(shCoef.w[5].b, shCoef.w[6].b, shCoef.w[7].b, shCoef.w[8].b));
	}
}